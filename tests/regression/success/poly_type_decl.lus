type UserType<<T1; T2>> = [T1, T2];  
type UserType2<<T>> = [int, UserType<<T; int>>];
type UserType3<<T>> = T;

type R<<T>> = struct {
  f1: UserType2<<T>>;
  f2: bool;
};

type R_real = R<<real>>;

node F<<T>>() returns (z: UserType2<<T>>; w: int);
let
  z = any { x: UserType2<<T>> | x.%0 > 0 };
  w = any { n: int | z.%0 > 0 };
tel

node Q<<T1>>(y:UserType3<<T1>>) returns (z:UserType3<<T1>>);
let
  z=y;
  check z=y;
tel

node R<<T1>>(y:T1) returns (z:UserType3<<T1>>);
let
  z=y;
  check z=y;
tel

node N(x: UserType2<<real>>) returns (y: UserType2<<real>>; z: R_real);
let
  y = x;
  z = R_real { f1 = x; f2 = true };
  check y = x;
  check z.f1 = x;
tel
